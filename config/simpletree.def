#include "Math/GenVector/LorentzVector.h"
#include "Math/GenVector/PtEtaPhiM4D.h"
#include "TVector2.h"

typedef ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double>> LorentzVectorM;

enum HLTPath {
  kPhoton120,
  kPhoton135MET100,
  kPhoton165HE10,
  kPhoton175,
  kEle23Loose,
  kEle27Loose,
  kMu20,
  kTrkMu20,
  kMu24eta2p1,
  kMu27,
  kMET170,
  kMETNoMu90MHTNoMu90,
  kMETNoMu120MHTNoMu120,
  nHLTPaths
};

[Particle:MAX=256]
pt/F
eta/F
phi/F
virtual LorentzVectorM p4() const { return LorentzVectorM(pt, eta, phi, 0.); }

[ParticleM:Particle]
mass/F
LorentzVectorM p4() const override { return LorentzVectorM(pt, eta, phi, mass); }

[Jet:ParticleM]

[Met:SINGLE]
met/F
phi/F
sumEt/F
virtual TVector2 v() const { TVector2 vec; vec.SetMagPhi(met, phi); return vec; }

[CorrectedMet:Met]
metCorrUp/F
phiCorrUp/F
metCorrDown/F
phiCorrDown/F
virtual TVector2 vCorr(int corr = 0) const { if (corr == 0) return v(); TVector2 vec; switch (corr) { case 1: vec.SetMagPhi(metCorrUp, phiCorrUp); break; case -1: vec.SetMagPhi(metCorrDown, phiCorrDown); break; } return vec; }

[Photon:Particle]
chIso/F
nhIso/F
phIso/F
sieie/F
hOverE/F
genIso/F
mipEnergy/F
mipChi2/F
mipSlope/F
mipIntercept/F
mipNhitCone/s
mipIsHalo/O
e15/F
e25/F
e33/F
e55/F
r9/F
etaWidth/F
phiWidth/F
s4/F
time/F
timeSpan/F
matchedGen/I
isEB/O
pixelVeto/O
electronVeto/O
csafeVeto/O
loose/O
medium/O
tight/O
highpt/O
matchHLT120/O
matchHLT135MET100/O
matchHLT165HE10/O
matchHLT175/O
bool passCHIso(UInt_t wp) const { return chIso < chIsoCuts[isEB ? 0 : 1][wp]; }
bool passNHIso(UInt_t wp) const { return nhIso < nhIsoCuts[isEB ? 0 : 1][wp]; }
bool passPhIso(UInt_t wp) const { return phIso < phIsoCuts[isEB ? 0 : 1][wp]; }
bool passSieie(UInt_t wp) const { return sieie < sieieCuts[isEB ? 0 : 1][wp]; }
bool passHOverE(UInt_t wp) const { return hOverE < hOverECuts[isEB ? 0 : 1][wp]; }
static double const chIsoCuts[2][3]{{2.44, 1.31, 0.91}, {1.84, 1.25, 0.65}};
static double const nhIsoCuts[2][3]{{2.57, 0.60, 0.33}, {4., 1.65, 0.93}};
static double const phIsoCuts[2][3]{{1.92, 1.33, 0.61}, {2.15, 1.02, 0.54}};
static double const sieieCuts[2][3]{{0.0103, 0.01, 0.01}, {0.0277, 0.0267, 0.0267}};
static double const hOverECuts[2][3]{{0.05, 0.05, 0.05}, {0.05, 0.05, 0.05}};

[Lepton:ParticleM]
int charge() const { return positive ? 1 : -1; }
matchedGen/I
tauDecay/O
hadDecay/O
positive/O
loose/O
tight/O

[Electron:Lepton]
chIsoPh/F
nhIsoPh/F
phIsoPh/F
sieie/F
hOverE/F
isEB/O
veto/O
matchHLT23Loose/O
matchHLT27Loose/O
matchHLT120Ph/O
matchHLT135MET100Ph/O
matchHLT165HE10Ph/O
matchHLT175Ph/O
bool passCHIsoPh(UInt_t wp) const { return chIsoPh < Photon::chIsoCuts[isEB ? 0 : 1][wp]; }
bool passNHIsoPh(UInt_t wp) const { return nhIsoPh < Photon::nhIsoCuts[isEB ? 0 : 1][wp]; }
bool passPhIsoPh(UInt_t wp) const { return phIsoPh < Photon::phIsoCuts[isEB ? 0 : 1][wp]; }
bool passSieiePh(UInt_t wp) const { return sieie < Photon::sieieCuts[isEB ? 0 : 1][wp]; }
bool passHOverEPh(UInt_t wp) const { return hOverE < Photon::hOverECuts[isEB ? 0 : 1][wp]; }

[Muon:Lepton]
matchHLT20/O
matchHLTTrk20/O
matchHLT24/O
matchHLT27/O

[Tau:ParticleM]
decayMode/O
combIso/F

[Parton:ParticleM]
pid/I
status/S
frixIso/O

[MCParticle:ParticleM]
pid/I
ancestor/s

[GenJet:Jet]

[HLT:SIZE=nHLTPaths]
pass/O

[MetFilters:SINGLE]
cschalo/O
hbhe/O
badsc/O
badTrack/O
badMuonTrack/O
virtual bool pass() const { return !cschalo && !hbhe && !badsc && !badTrack && !badMuonTrack; }

[ReweightScale:MAX=256]
scale/F

{Event}
run/i
lumi/i
event/i
weight/D
rho/D
npv/s
partons/PartonCollection
partonFinalStates/MCParticleCollection
jets/JetCollection
genJets/GenJetCollection
photons/PhotonCollection
electrons/ElectronCollection
muons/MuonCollection
taus/TauCollection
rawMet/Met
t1Met/CorrectedMet
genMet/Met
hlt/HLTCollection
metFilters/MetFilters
reweight/ReweightScaleCollection
