#include "Math/GenVector/LorentzVector.h"
#include "Math/GenVector/PtEtaPhiM4D.h"
#include "TLorentzVector.h"
#include "TVector2.h"

#include <cmath>

typedef ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double>> LorentzVectorM;

enum PhotonL1Object {
  fSEG34IorSEG40,
  fSEG40IorSJet200,
  fSEG34IorSEG40IorSJet200,
  fSEG24,
  fSEG30,
  fSEG40,
  nPhotonL1Objects
};

enum PhotonHLTObject {
  fPh120,
  fPh135,
  fPh165HE10,
  fPh175,
  fPh22EBR9Iso,
  fPh36EBR9Iso,
  fPh50EBR9Iso,
  fPh75EBR9Iso,
  fPh90EBR9Iso,
  fPh120EBR9Iso,
  nPhotonHLTObjects
};

enum ElectronHLTObject {
  fEl23Loose,
  fEl27Loose,
  fEl120Ph,
  fEl135Ph,
  fEl165HE10Ph,
  fEl175Ph,
  fEl22EBR9IsoPh,
  fEl36EBR9IsoPh,
  fEl50EBR9IsoPh,
  fEl75EBR9IsoPh,
  fEl90EBR9IsoPh,
  fEl120EBR9IsoPh,
  nElectronHLTObjects
};

enum MuonHLTObject {
  fMu20,
  fMuTrk20,
  fMu24,
  fMu27,
  nMuonHLTObjects
};

[Particle:MAX=256]
pt/F
eta/F
phi/F
virtual LorentzVectorM p4() const { return LorentzVectorM(pt, eta, phi, 0.); }
virtual TLorentzVector p4v() const { TLorentzVector p4; p4.SetPtEtaPhiM(pt, eta, phi, 0.); return p4; }
double dEta(Particle const& p) const { return eta - p.eta; }
double dPhi(Particle const& p) const { return TVector2::Phi_mpi_pi(phi - p.phi); }
double dR2(Particle const& p) const { double d1(dEta(p)); double d2(dPhi(p)); return d1 * d1 + d2 * d2; }
double dR(Particle const& p) const { return std::sqrt(dR2(p)); }

[ParticleM:Particle]
mass/F
LorentzVectorM p4() const override { return LorentzVectorM(pt, eta, phi, mass); }
TLorentzVector p4v() const override { TLorentzVector p4; p4.SetPtEtaPhiM(pt, eta, phi, mass); return p4; }

[Jet:ParticleM]
mjid/O
ptRaw/F
ptCorrUp/F
ptCorrDown/F
ptResUp/F
ptResDown/F
cisv/F

[Met:SINGLE]
met/F
phi/F
sumEt/F
virtual TVector2 v() const { TVector2 vec; vec.SetMagPhi(met, phi); return vec; }

[CorrectedMet:Met]
metCorrUp/F
phiCorrUp/F
metCorrDown/F
phiCorrDown/F
metResUp/F
phiResUp/F
metResDown/F
phiResDown/F
metUnclUp/F
phiUnclUp/F
metUnclDown/F
phiUnclDown/F
virtual TVector2 vCorr(int corr = 0) const { if (corr == 0) return v(); TVector2 vec; switch (corr) { case 1: vec.SetMagPhi(metCorrUp, phiCorrUp); break; case -1: vec.SetMagPhi(metCorrDown, phiCorrDown); break; } return vec; }

[Photon:Particle]
chIso/F
chWorstIso/F
chIsoMax/F
nhIso/F
phIso/F
ecalIso/F
hcalIso/F
sieie/F
sipip/F
sieip/F
hOverE/F
genIso/F
mipEnergy/F
mipChi2/F
mipSlope/F
mipIntercept/F
mipNhitCone/s
mipIsHalo/O
e13/F
e31/F
e15/F
e22/F
e25/F
e33/F
e44/F
e55/F
emax/F
e2nd/F
e4/F
r9/F
etaWidth/F
phiWidth/F
time/F
timeSpan/F
genMatchDR/F
matchedGen/I
isEB/O
pixelVeto/O
electronVeto/O
csafeVeto/O
loose/O
medium/O
tight/O
highpt/O
matchL1[nPhotonL1Objects]/O
matchHLT[nPhotonHLTObjects]/O

bool passCHIso(UInt_t wp) const { return chIso < chIsoCuts[isEB ? 0 : 1][wp]; }
bool passNHIso(UInt_t wp) const { return nhIso < nhIsoCuts[isEB ? 0 : 1][wp]; }
bool passPhIso(UInt_t wp) const { return phIso < phIsoCuts[isEB ? 0 : 1][wp]; }
bool passSieie(UInt_t wp) const { return sieie < sieieCuts[isEB ? 0 : 1][wp]; }
bool passHOverE(UInt_t wp) const { return hOverE < hOverECuts[isEB ? 0 : 1][wp]; }
static double const chIsoCuts[2][3]{{3.32, 1.37, 0.76}, {1.97, 1.10, 0.56}};
static double const nhIsoCuts[2][3]{{1.92, 1.06, 0.97}, {11.86, 2.69, 2.09}};
static double const phIsoCuts[2][3]{{0.81, 0.28, 0.08}, {0.83, 0.39, 0.16}};
static double const sieieCuts[2][3]{{0.0102, 0.0102, 0.0100}, {0.0274, 0.0268, 0.0268}};
static double const hOverECuts[2][3]{{0.05, 0.05, 0.05}, {0.05, 0.05, 0.05}};

[Lepton:Particle]
int charge() const { return positive ? 1 : -1; }
matchedGen/I
tauDecay/O
hadDecay/O
positive/O
loose/O
tight/O

[Electron:Lepton]
LorentzVectorM p4() const override { return LorentzVectorM(pt, eta, phi, 5.11e-4); }
TLorentzVector p4v() const override { TLorentzVector p4; p4.SetPtEtaPhiM(pt, eta, phi, 5.11e-4); return p4; }
chIsoPh/F
nhIsoPh/F
phIsoPh/F
combRelIso/F
ecalIso/F
hcalIso/F
sieie/F
sipip/F
sieip/F
hOverE/F
isEB/O
veto/O
matchHLT[nElectronHLTObjects]/O

bool passCHIsoPh(UInt_t wp) const { return chIsoPh < Photon::chIsoCuts[isEB ? 0 : 1][wp]; }
bool passNHIsoPh(UInt_t wp) const { return nhIsoPh < Photon::nhIsoCuts[isEB ? 0 : 1][wp]; }
bool passPhIsoPh(UInt_t wp) const { return phIsoPh < Photon::phIsoCuts[isEB ? 0 : 1][wp]; }
bool passSieiePh(UInt_t wp) const { return sieie < Photon::sieieCuts[isEB ? 0 : 1][wp]; }
bool passHOverEPh(UInt_t wp) const { return hOverE < Photon::hOverECuts[isEB ? 0 : 1][wp]; }

[Muon:Lepton]
LorentzVectorM p4() const override { return LorentzVectorM(pt, eta, phi, 0.1057); }
TLorentzVector p4v() const override { TLorentzVector p4; p4.SetPtEtaPhiM(pt, eta, phi, 0.1057); return p4; }
combRelIso/F
matchHLT[nMuonHLTObjects]/O

[Tau:ParticleM]
decayMode/O
combIso/F

[Parton:ParticleM]
pid/B

[MCParticle:ParticleM]
pid/I
ancestor/b

[GenJet:ParticleM]

[HLTBits:SINGLE]
void set(unsigned iB) { words[iB / 32] |= (1 << (iB % 32)); }
bool pass(unsigned iB) const { return ((words[iB / 32] >> (iB % 32)) & 1) != 0; }
words[16]/i

[MetFilters:SINGLE]
cschalo/O
hbhe/O
hbheIso/O
badsc/O
badTrack/O
badMuonTrack/O
virtual bool pass() const { return !cschalo && !hbhe && !hbheIso && !badsc && !badTrack && !badMuonTrack; }

{Event}
run/i
lumi/i
event/i
weight/D = 1.
scaleReweight[6]/D
pdfDW/D
rho/D
npvTrue/F
npv/s
partons/PartonCollection
promptFinalStates/MCParticleCollection
jets/JetCollection
genJets/GenJetCollection
photons/PhotonCollection
electrons/ElectronCollection
muons/MuonCollection
taus/TauCollection
rawMet/Met
t1Met/CorrectedMet
genMet/Met
hltBits/HLTBits
metFilters/MetFilters

{Run}
run/i
hltMenu/i
